= Querying with RedisVL
:navtitle: Hybrid Queries

In this guide, we will explore more complex queries that can be performed with RedisVL.

== Hybrid Search: Text + Vector

RedisVL supports true hybrid search that combines both text and vector similarity in a single query using the `HybridQuery` class. This is different from filtered vector search - it actually scores documents based on a weighted combination of both text relevance and vector similarity.

=== Basic HybridQuery

A `HybridQuery` combines full-text search with vector similarity search:

[source,java]
----
import com.redis.vl.query.HybridQuery;

// Create a hybrid query combining text and vector search
HybridQuery query = HybridQuery.builder()
    .text("medical professional with expertise")
    .textFieldName("description")
    .vector(queryVector)
    .vectorFieldName("embedding")
    .numResults(10)
    .build();

List<Map<String, Object>> results = index.query(query);
----

The results are scored using:
```
hybrid_score = (alpha) * vector_similarity + (1-alpha) * text_score
```

Where `alpha` (default 0.7) controls the balance between vector and text similarity.

=== Adjusting the Alpha Parameter

Control the balance between text and vector similarity:

[source,java]
----
// Favor vector similarity (alpha = 0.9)
HybridQuery vectorFocused = HybridQuery.builder()
    .text("search terms")
    .textFieldName("description")
    .vector(queryVector)
    .vectorFieldName("embedding")
    .alpha(0.9f)  // 90% vector, 10% text
    .build();

// Balanced approach (alpha = 0.5)
HybridQuery balanced = HybridQuery.builder()
    .text("search terms")
    .textFieldName("description")
    .vector(queryVector)
    .vectorFieldName("embedding")
    .alpha(0.5f)  // 50% vector, 50% text
    .build();

// Favor text relevance (alpha = 0.3)
HybridQuery textFocused = HybridQuery.builder()
    .text("search terms")
    .textFieldName("description")
    .vector(queryVector)
    .vectorFieldName("embedding")
    .alpha(0.3f)  // 30% vector, 70% text
    .build();
----

=== Adding Filters to HybridQuery

Filter hybrid search results using either Filter objects or raw Redis query strings:

==== Using Filter Objects

[source,java]
----
import com.redis.vl.query.Filter;

// Create filters
Filter filter = Filter.and(
    Filter.tag("category", "technology"),
    Filter.numeric("rating").gte(4.0)
);

// Apply to hybrid query
HybridQuery query = HybridQuery.builder()
    .text("artificial intelligence")
    .textFieldName("description")
    .vector(queryVector)
    .vectorFieldName("embedding")
    .filterExpression(filter)
    .build();
----

==== Using String Filter Expressions (New in v0.0.2)

For advanced use cases, you can pass raw Redis filter query strings:

[source,java]
----
// Use raw Redis query syntax
String customFilter = "@category:{tech|science|engineering} @rating:[4.0 +inf]";

HybridQuery query = HybridQuery.builder()
    .text("machine learning")
    .textFieldName("description")
    .vector(queryVector)
    .vectorFieldName("embedding")
    .filterExpression(customFilter)  // String filter!
    .build();
----

This is useful when:

* You need Redis query syntax not yet supported by Filter objects
* You're migrating from raw Redis queries
* You want direct control over the query syntax

=== Custom Stopwords

Control which words are filtered from the text query:

[source,java]
----
import java.util.Set;

// Use custom stopwords
Set<String> customStopwords = Set.of("the", "a", "an", "to");

HybridQuery query = HybridQuery.builder()
    .text("the quick brown fox")
    .textFieldName("description")
    .vector(queryVector)
    .vectorFieldName("embedding")
    .stopwords(customStopwords)
    .build();
----

=== Complete HybridQuery Example

[source,java]
----
import com.redis.vl.index.SearchIndex;
import com.redis.vl.schema.IndexSchema;
import com.redis.vl.query.HybridQuery;
import com.redis.vl.query.Filter;

// Define schema with text and vector fields
String schemaYaml = """
    version: '0.1.0'
    index:
      name: articles-index
      prefix: article
      storage_type: hash
    fields:
      - name: title
        type: text
      - name: content
        type: text
      - name: category
        type: tag
      - name: rating
        type: numeric
      - name: embedding
        type: vector
        attrs:
          dims: 384
          distance_metric: cosine
          algorithm: flat
          datatype: float32
    """;

IndexSchema schema = IndexSchema.fromYaml(schemaYaml);
SearchIndex index = new SearchIndex(schema, jedis);
index.create(true);

// Perform hybrid search with filter
Filter filter = Filter.and(
    Filter.tag("category", "technology"),
    Filter.numeric("rating").gte(4.0)
);

HybridQuery query = HybridQuery.builder()
    .text("machine learning artificial intelligence")
    .textFieldName("content")
    .vector(queryVector)  // Your embedding vector
    .vectorFieldName("embedding")
    .filterExpression(filter)
    .alpha(0.7f)  // 70% vector, 30% text
    .numResults(10)
    .returnFields(List.of("title", "category", "rating"))
    .build();

List<Map<String, Object>> results = index.query(query);

// Results are sorted by hybrid_score (descending)
for (Map<String, Object> result : results) {
    System.out.println("Title: " + result.get("title"));
    System.out.println("Score: " + result.get("hybrid_score"));
    System.out.println("---");
}
----

== Filtered Vector Search

Filtered vector search is different from hybrid search - it applies filters before or after vector search, but doesn't combine text and vector scoring. For filtered vector queries, see <<Pre-Filtering vs Post-Filtering>>.

== Filter Types

RedisVL supports several filter types corresponding to Redis field types:

=== Tag Filters

Tag filters are filters that are applied to tag fields. These are fields that are not tokenized and are used to store a single categorical value:

[source,java]
----
import com.redis.vl.query.Filter;

// Match a single tag (use $.field for JSON storage)
Filter colorFilter = Filter.tag("$.color", "red");

// Match one of multiple tags
Filter categoryFilter = Filter.tag("$.category", "electronics", "computers", "phones");
----

=== Numeric Filters

Numeric filters are filters that are applied to numeric fields and can be used to isolate a range of values for a given field:

[source,java]
----
// Between two values (inclusive) - use $.field for JSON storage
Filter priceFilter = Filter.numeric("$.price").between(10.0, 100.0);

// Greater than
Filter ageFilter = Filter.numeric("$.age").gt(18);

// Less than
Filter scoreFilter = Filter.numeric("$.score").lt(100);

// Greater than or equal
Filter ratingFilter = Filter.numeric("$.rating").gte(4.0);

// Less than or equal
Filter maxFilter = Filter.numeric("$.max_value").lte(1000);

// Equal to
Filter exactFilter = Filter.numeric("$.quantity").eq(5);
----

=== Text Filters

Text filters are filters that are applied to text fields. These filters are applied to the entire text field. For example, if you have a text field that contains the text "The quick brown fox jumps over the lazy dog", a text filter of "quick" will match this text field:

[source,java]
----
// Full-text search (matches words) - use $.field for JSON storage
Filter descFilter = Filter.text("$.description", "redis vector");

// Exact phrase (use quotes)
Filter exactPhrase = Filter.text("$.content", "\"exact phrase here\"");
----

=== Combining Filters

Combine multiple filters using boolean logic:

[source,java]
----
// AND - all conditions must be true
Filter andFilter = Filter.and(
    Filter.tag("$.status", "active"),
    Filter.numeric("$.age").between(18, 65)
);

// OR - at least one condition must be true
Filter orFilter = Filter.or(
    Filter.tag("$.category", "electronics"),
    Filter.tag("$.category", "computers")
);

// NOT - negate a condition
Filter notFilter = Filter.not(
    Filter.tag("$.status", "deleted")
);

// Complex combinations
Filter complexFilter = Filter.and(
    Filter.or(
        Filter.tag("$.type", "premium"),
        Filter.numeric("$.score").gte(80)
    ),
    Filter.not(Filter.tag("$.status", "expired"))
);
----

== Pre-Filtering vs Post-Filtering

=== Pre-Filtering (Recommended)

Pre-filtering applies filters *before* the vector search. This is more efficient as it reduces the search space:

[source,java]
----
import com.redis.vl.query.VectorQuery;

Filter filter = Filter.and(
    Filter.tag("$.category", "electronics"),
    Filter.numeric("$.price").between(100, 1000)
);

VectorQuery query = VectorQuery.builder()
    .vector(queryVector)
    .field("embedding")
    .numResults(10)
    .withPreFilter(filter.build())  // Apply before vector search
    .build();

List<Map<String, Object>> results = index.query(query);
----

=== Post-Filtering

Post-filtering applies filters *after* the vector search. Use this when you want to find similar items first, then filter the results:

[source,java]
----
VectorQuery query = VectorQuery.builder()
    .vector(queryVector)
    .field("embedding")
    .numResults(100)  // Get more results initially
    .build();

// Get results
List<Map<String, Object>> results = index.query(query);

// Apply filter in application code
results = results.stream()
    .filter(doc -> {
        String category = (String) doc.get("$.category");
        double price = ((Number) doc.get("$.price")).doubleValue();
        return "electronics".equals(category) && price >= 100 && price <= 1000;
    })
    .limit(10)
    .collect(Collectors.toList());
----

IMPORTANT: Pre-filtering is generally more efficient as it leverages Redis's indexing capabilities.

== Complete Example: Product Search

Here's a complete example of a product search with hybrid queries:

[source,java]
----
import com.redis.vl.index.SearchIndex;
import com.redis.vl.schema.IndexSchema;
import com.redis.vl.query.VectorQuery;
import com.redis.vl.query.Filter;
import redis.clients.jedis.UnifiedJedis;

public class HybridQueryExample {
    public static void main(String[] args) {
        // Connect to Redis
        UnifiedJedis jedis = new UnifiedJedis("redis://localhost:6379");

        // Define schema
        Map<String, Object> schema = Map.of(
            "index", Map.of(
                "name", "products",
                "prefix", "product",
                "storage_type", "json"
            ),
            "fields", List.of(
                Map.of("name", "name", "type", "text"),
                Map.of("name", "category", "type", "tag"),
                Map.of("name", "price", "type", "numeric"),
                Map.of("name", "rating", "type", "numeric"),
                Map.of("name", "in_stock", "type", "tag"),
                Map.of(
                    "name", "description_embedding",
                    "type", "vector",
                    "attrs", Map.of(
                        "dims", 384,
                        "distance_metric", "cosine",
                        "algorithm", "flat",
                        "datatype", "float32"
                    )
                )
            )
        );

        // Create index
        SearchIndex index = new SearchIndex(new IndexSchema(schema), jedis);
        index.create(true);

        // Load sample products
        List<Map<String, Object>> products = List.of(
            Map.of(
                "name", "Laptop",
                "category", "electronics",
                "price", 899.99,
                "rating", 4.5,
                "in_stock", "yes",
                "description_embedding", generateEmbedding("high performance laptop")
            ),
            Map.of(
                "name", "Mouse",
                "category", "electronics",
                "price", 29.99,
                "rating", 4.2,
                "in_stock", "yes",
                "description_embedding", generateEmbedding("wireless mouse")
            ),
            Map.of(
                "name", "Desk",
                "category", "furniture",
                "price", 399.99,
                "rating", 4.7,
                "in_stock", "no",
                "description_embedding", generateEmbedding("standing desk")
            )
        );

        index.load(products);

        // Example 1: Find electronics under $100 with good ratings
        Filter filter1 = Filter.and(
            Filter.tag("$.category", "electronics"),
            Filter.numeric("$.price").lt(100),
            Filter.numeric("$.rating").gte(4.0),
            Filter.tag("$.in_stock", "yes")
        );

        float[] queryVector = generateEmbedding("computer accessories");

        VectorQuery query1 = VectorQuery.builder()
            .vector(queryVector)
            .field("description_embedding")
            .numResults(10)
            .withPreFilter(filter1.build())
            .returnFields("name", "category", "price", "rating")
            .build();

        List<Map<String, Object>> results1 = index.query(query1);
        System.out.println("Affordable electronics in stock:");
        results1.forEach(System.out::println);

        // Example 2: Find any highly-rated products
        Filter filter2 = Filter.and(
            Filter.numeric("$.rating").gte(4.5),
            Filter.tag("$.in_stock", "yes")
        );

        VectorQuery query2 = VectorQuery.builder()
            .vector(queryVector)
            .field("description_embedding")
            .numResults(5)
            .withPreFilter(filter2.build())
            .returnFields("name", "category", "price", "rating")
            .build();

        List<Map<String, Object>> results2 = index.query(query2);
        System.out.println("\nTop rated products:");
        results2.forEach(System.out::println);

        // Clean up
        jedis.close();
    }

    private static float[] generateEmbedding(String text) {
        // In a real application, use an embedding model
        // For demo purposes, return a random vector
        float[] embedding = new float[384];
        for (int i = 0; i < embedding.length; i++) {
            embedding[i] = (float) Math.random();
        }
        return embedding;
    }
}
----

== Range Queries

Perform range queries on numeric fields:

[source,java]
----
// Find products in a price range
Filter priceRange = Filter.numeric("$.price").between(50, 200);

// Find products with rating above threshold
Filter highRated = Filter.numeric("$.rating").gt(4.0);

// Combine ranges
Filter rangeFilter = Filter.and(
    Filter.numeric("$.price").between(50, 500),
    Filter.numeric("$.rating").gte(4.0),
    Filter.numeric("$.discount_percent").lte(30)
);
----

== Multi-Value Tag Filters

Search for items matching multiple tags:

[source,java]
----
// Match any of the specified categories
Filter categoryFilter = Filter.tag("$.category", "electronics", "computers", "phones");

// Match any of the specified colors
Filter colorFilter = Filter.tag("$.color", "red", "blue", "green");

// Combine with other filters
Filter multiFilter = Filter.and(
    categoryFilter,
    colorFilter,
    Filter.tag("$.in_stock", "yes")
);
----

== Tips for Effective Hybrid Queries

. *Use Pre-Filtering* - More efficient than post-filtering
. *Index Your Filters* - Make sure filtered fields are indexed in your schema
. *Balance Specificity* - Too many filters may return no results
. *Test Different Combinations* - Experiment with AND/OR combinations
. *Monitor Performance* - Use `index.info()` to check index statistics

== Next Steps

* xref:llmcache.adoc[LLM Cache] - Learn about semantic caching
* xref:vectorizers.adoc[Vectorizers] - Generate embeddings for your queries
* xref:hash-vs-json.adoc[Hash vs JSON] - Choose the right storage type
